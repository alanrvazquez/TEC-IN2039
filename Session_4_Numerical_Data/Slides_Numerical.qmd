---
title: |
   | Sesión 4: 
   | Datos Numéricos  
author: 
  - name: Alan R. Vázquez
    email: alanrvazquez@tec.mx
    affiliations:
      - name: Tecnológico de Monterrey
format: 
  revealjs:
    chalkboard: true
    multiplex: true
revealjs-plugins:
  - pointer
execute:
  echo: true  
editor: visual
slide-number: True
logo: IN2039_logo.png
css: style.css
---

## Los Tópicos de Hoy

[*Enfocarnos en 1 variable numérica.*]{style="color:darkblue;"}

<br/>

::: columns
::: {.column width="50%"}
1.  Resúmenes estadísticos
:::

::: {.column width="50%"}
2.  Gráfica de barras y circular
:::
:::

::: columns
::: {.column width="30%"}
3.  Transformando variables categóricas
:::

::: {.column width="70%"}
:::
:::

## Ejemplo

::: columns
::: {.column width="70%"}
Un pistón es un dispositivo mecánico que está presente en la mayoría de los motores.
:::

::: {.column width="30%"}
![](images/clipboard-545995500.png){width="402"}
:::
:::

Una medida del rendimiento de un pistón es el tiempo que lleva en completar un ciclo, lo cual llamamos "tiempo de ciclo" y se mide en segundos.

El archivo `CYLT.xlsx` contiene 50 tiempos de ciclo de un pistón operado en condiciones de funcionamiento fijas.

## Carguemos los datos en R

```{r}

library(readxl) # Para leer datos.
library(ggplot2) # Para visualizar.
library(ggformula) # Para visualizar.

piston_data <- read_excel("CYCLT.xlsx") # Leer los datos.
head(piston_data) # Ver las primeras 6 observaciones.
```

En R, los datos numéricos se llaman `numeric`. Preguntemos si R reconoce nuestros datos correctamente.

```{r}
#| output: true

is.numeric(piston_data$cycle_time)
```

## Resúmenes estadísticos

> Un **resumén estadístico** nos ayuda a resumir un conjunto de observaciones de una manera simple.

Los resúmenes estadísticos más utilizados para datos numéricos son:

-   [Promedio]{style="color:darkblue;"}
-   [Varianza]{style="color:darkblue;"} y [Desviación estándar]{style="color:darkblue;"}
-   [Mediana]{style="color:darkblue;"} y [cuartiles]{style="color:darkblue;"}
-   [Máximo]{style="color:darkblue;"} y [mínimo]{style="color:darkblue;"}

## Promedio

> Indica el centro de las observaciones.

Para calcularlo, considera $n$ observaciones denotadas como $y_1, y_2, \ldots, y_n$.

El promedio es

$$\bar{y} = \frac{1}{n}\sum_{i=1}^{n} y_i$$

## 

En R, el promedio se calcula usando la función `mean`.

```{r}
#| output: true

mean(piston_data$cycle_time)
```

<br/>

[*Interpretación:*]{style="color:darkgray;"} En promedio, un pistón tarda 0.65246 segundos en completar un ciclo.

## Varianza

> Indica que tan dispersos están las observaciones.

Para calcularla, considera $n$ observaciones denotadas usando $y_1, y_2, \ldots, y_n$ . La varianza es

$$
s^2 = \frac{1}{n-1} \sum_{i=1}^{n} (y_i - \bar{y})^2
$$

*Es como un promedio de las diferencias al cuadrado entre cada observación y el promedio.*

## 

En R, la varianza se calcula usando la función `var`.

```{r}
#| output: true

var(piston_data$cycle_time)
```

<br/> [*Interpretación:*]{style="color:darkgray;"} La varianza de los tiempos de ciclo de los pistones es 0.1391073.

## Desviación estándar

Desafortunadamente, la varianza no está en la misma escala que las observaciones, ya que las diferencias entre cada observación y la media muestral se elevan al cuadrado.

Para obtener una medida de dispersión cuyas unidades sean las mismas que las de las observaciones, tomamos la raíz cuadrada de la varianza.

$$
s = \left(\frac{1}{n-1} \sum_{i=1}^{n} (y_i - \bar{y})^2 \right)^{1/2}
$$

Esta es la desviación estándar.

## 

En R, la desviación estándar se calcula usando la función `sd`.

```{r}
#| output: true

sd(piston_data$cycle_time)
```

<br/>

[*Interpretación:*]{style="color:darkgray;"} En promedio, un pistón tarda 0.65246 segundos en completar un ciclo, con una diferencia de mas o menos 0.3729709 segundos.

## Mediana y Cuartiles

La [**mediana**]{style="color:darkgreen;"} de la muestra es el número medio de las observaciones ordenadas de menor a mayor.

Los [**cuartiles**]{style="color:darkgreen;"} dividen las observaciones en cuatro partes. Existen tres de ellos:

-   El primer cuartil ($Q_1$) es la mediana de la mitad inferior de las observaciones.

-   El segundo cuartil ($Q_2$) es la mediana de las observaciones.

-   El tercer cuartil ($Q_3$) es la mediana de la mitad superior de las observaciones.

## 

![](images/clipboard-1950324610.png)

## 

En R, la mediana se calcula con la función `median`.

```{r}
median(piston_data$cycle_time)
```

[*Interpretación:*]{style="color:darkgray;"} El 50% de los tiempos de ciclo de los pistones es menor que 0.5455 segundos.

Los cuartiles se calculan con la función `quantile`.

```{r}
quantile(piston_data$cycle_time)
```

[*Interpretación:*]{style="color:darkgray;"} El 25%, 50% y 75% de los tiempos de ciclo de los pistones es menor que 0.3050, 0.5455 y 1.0690 segundos, respectivamente.

## Máximo y mínimo

Por supuesto que otros estadísticos relevantes son el **máximo** y el **mínimo**, que se calculan con las funciones `max` y `min`, respectivamente.

```{r}
max(piston_data$cycle_time)
```

[*Interpretación:*]{style="color:darkgray;"} El tiempo de ciclo máximo de un pistón es 1.141 segundos.

```{r}
min(piston_data$cycle_time)
```

[*Interpretación:*]{style="color:darkgray;"} El tiempo de ciclo mínimo de un pistón es 0.175 segundos.

# Gráficas para datos numéricos

## Principio 1

> Formula la pregunta de interés.

Las preguntas típicas sobre una variable numérica son:

-   ¿Cuál es la forma de los datos (observaciones) de la variable *X*?

-   ¿Existen observaciones inusuales en la variable *X*?

## Principio 2

> Transforma los datos en información.

Tres tipos comunes de graficas para visualizar una variable numérica son:

-   Histogramas.
-   Curvas de densidad.
-   Gráficas de cajas.

Básicamente, son maneras distintas de visualizar la "forma" o [*distribución*]{style="color:darkred;"} de la variable.

## Histograma

Da una idea de la distribución de las observaciones, indicando regiones donde las observaciones están concentradas o son escasas.

Se construye usando una ***tabla de frecuencia***.

1.  Define un número máximo de categorías o *bins* (de 5 a 30).
2.  Define los rangos de las categorías.
3.  Agrupa las observaciones en sus categorías correspondientes.

## Tabla de frecuencia

R calcula automáticamente la tabla de frecuencia para datos numéricos.

```{r}
#| echo: false
#| output: true

table(cut_interval(piston_data$cycle_time, 20))

```

El histograma es una visualización de esta tabla.

## 

En `ggplot2` puedes construir un histograma usando el siguiente comando.

```{r}
#| fig-pos: center

gf_histogram( ~ cycle_time, data = piston_data, bins = 13) 
```

::: notes
Las barras del histograma se tocan entre sí. Un espacio indica que no hay observaciones en ese intervalo.
:::

## Mejora la gráfica

Para transmitir un mejor mensaje, añade las siguientes opciones.

```{r}
#| fig-pos: center

gf_histogram( ~ cycle_time, data = piston_data, bins = 13, 
              color = "black", fill = "white")
```

## O mejor aún, aplica el Principio 3

> Enriquece la gráfica con información adicional.

```{r}
#| fig-pos: center

gf_histogram( ~ cycle_time, data = piston_data, bins = 13, 
              color = "black", fill = "white") + labs(title = "Histograma de tiempo de ciclo", x = "Tiempo de ciclo (segundos)", y = "Frequencia", caption = "Datos de 50 pistones")
```

## No es lo mismo que una gráfica de barras

Con datos cateóricos, la gráfica de barras se parece al histograma porque presenta la frecuencia de las categorías.

Sin embargo, no podemos interpretar la forma del diagrama de barras de la misma manera que un histograma.

1.  La frecuencia de una categoría está representada por la altura de la barra y el ancho no contiene información.

2.  Una gráfica de barras no te señalará valores atípicos.

::: notes
Tails and symmetry do not make sense in this setting.
:::

## ¿Cómo defino el número de intervalos?

[El número de intervalos afecta el aspecto del histograma. El histograma izquierdo usa `bins = 13` y el histograma derecho usa `bins = 5`.]{style="font-size: 80%;"}

::: columns
::: {.column width="50%"}
```{r}
#| fig-pos: center
#| echo: false

gf_histogram( ~ cycle_time, data = piston_data, bins = 5, 
              color = "black", fill = "white") + labs(title = "Histograma de tiempo de ciclo", x = "Tiempo de ciclo (segundos)", y = "Frequencia", caption = "Datos de 50 pistones")
```
:::

::: {.column width="50%"}
```{r}
#| fig-pos: center
#| echo: false

gf_histogram( ~ cycle_time, data = piston_data, bins = 30, 
              color = "black", fill = "white") + labs(title = "Histograma de tiempo de ciclo", x = "Tiempo de ciclo (segundos)", y = "Frequencia", caption = "Datos de 50 pistones")
```
:::
:::

::: notes
The histogram is a familiar type of plot that uses smoothing. A histogram aggregates data values by putting points into bins and plotting one bar for each bin. Smoothing here means that we cannot differentiate the location of individual points in a bin: the points are smoothly allocated across their bins.
:::

## Suavizado

-   El histograma es un tipo de gráfico que utiliza ***suavizado***.

-   Es decir, agrega valores de datos colocando puntos en contenedores y trazando una barra para cada contenedor.

-   Suavizar aquí significa que no podemos diferenciar la ubicación de puntos individuales en un contenedor: los puntos se asignan suavemente entre sus contenedores.

## 

::: columns
::: {.column width="50%"}
Con pocos intervalos anchos, hemos suavizado demasiado la distribución, lo que hace imposible discernir posibles colas o valores atípicos.
::: 
::: {.column width="50%"}
```{r}
#| fig-pos: center
#| echo: false

gf_histogram( ~ cycle_time, data = piston_data, bins = 5, 
              color = "black", fill = "white") + labs(title = "Histograma de tiempo de ciclo", x = "Tiempo de ciclo (segundos)", y = "Frequencia", caption = "Datos de 50 pistones")
```
:::
:::

::: columns
::: {.column width="50%"}
Por otro lado, demasiados intervalos dan un gráfico demasiado detallado.
::: 
::: {.column width="50%"}
```{r}
#| fig-pos: center
#| echo: false

gf_histogram( ~ cycle_time, data = piston_data, bins = 30, 
              color = "black", fill = "white") + labs(title = "Histograma de tiempo de ciclo", x = "Tiempo de ciclo (segundos)", y = "Frequencia", caption = "Datos de 50 pistones")
```
:::
:::


::: notes
In both histograms, it’s hard to see the shape of the distribution. With a few wide bins (the plot on the left), we have over-smoothed the distribution, which makes it impossible to discern modes and tails. On the other hand, too many bins (the plot on the right) gives a plot that’s little better than a rug plot.
:::

## 

- La función `gf_histogram` elige automáticamente el número de intervalos. 

- Sin embargo, este parámetro (`bin` en la función) a menudo necesita un poco de modificación para crear el histograma más útil. 

- En presencia de un parámetro de ajuste, es importante probar algunos valores diferentes antes de decidirse por uno.


::: notes
Most histogram and KDE software automatically choose the bin width for the histogram and the bandwidth for the kernel. However, these parameters often need a bit of fiddling to create the most useful plot. When you create visualizations that rely on tuning parameters, it’s important to try a few different values before settling on one.
:::

## Curva de densidad

La curva de densidad es una versión extrema pero inteligente de suavizado a un histograma.

Se basa en la frecuencia relativa (#observaciónes_en_categoria/total), en lugar de la frecuencia

En R, se obtiene usando la función `df_density()`.

::: columns
::: {.column width="50%"}
```{r}
#| output: false
#| fig-pos: center

gf_density(~ cycle_time, 
           data = piston_data)
```
::: 
::: {.column width="50%"}
```{r}
#| echo: false
#| fig-pos: center

gf_density(~ cycle_time, data = piston_data)
```
:::
:::

##

```{r}
#| echo: false
#| fig-pos: center

gf_density(~ cycle_time, data = piston_data)
```

La curva es inteligente porque estima la distribución real de la variable númerica usando un método llamado *Kernel Density Estimation*.


## ¿Qué buscar en un histograma o curva de densidad?

- La simetría y la asimetría de la distribución
- El número, ubicación y tamaño de las regiones (intervalos) de alta frecuencia
- La longitud de las colas (a menudo en comparación con una curva en forma de campana).
- Brechas donde no se observan valores
- Valores inusualmente grandes o anómalos.

## Gáfica de Caja

Una gráfica de caja nos ayuda a visualizar la distribución de las observaciones usando cuartiles.

- Es muy efectiva para detectar "valores atípicos".

Un componente importante de la gráfica es el **rango intercuartil** (*IQR*), que es la diferencia entre el tercer cuartil y el primer cuartil ($Q_3 - Q_1$). 

> El rango intercuartil es la distancia necesaria para abarcar la mitad media de los datos.

## Anatomía de una gráfica de Caja

![](images/clipboard-84021266.png)

Te invito a conocer más en esa liga [**https://towardsdatascience.com/why-1-5-in-iqr-method-of-outlier-detection-5d07fdc82097**](https://towardsdatascience.com/why-1-5-in-iqr-method-of-outlier-detection-5d07fdc82097){.uri}

## 

Para construir una gráfica de caja, utiliza la función `gf_boxplot()`.

::: columns
::: {.column width="50%"}
```{r}
#| fig-align: center
#| output: false
gf_boxplot(cycle_time ~ 1, 
          data = piston_data)
```
:::
::: {.column width="50%"}
```{r}
#| fig-align: center
#| echo: false

gf_boxplot( cycle_time ~ 1, data = piston_data)
```
:::
:::

Note la sintaxis expecial en este caso `cycle_time ~ 1`. Si usas  `~ cycle_time`, obtendrás la gráfica de caja en horizontal.

## La gráfica de violín

La gráfica de violín combina la curva de densidad con la gráfica de caja. Los trazados de violín dibujan curvas de densidad a lo largo de un eje. La curva se invierte para crear una forma simétrica de "violín".

En R, usa la función `gf_violin()`.

::: columns
::: {.column width="50%"}
```{r}
#| fig-align: center
#| output: false
gf_violin(cycle_time ~ 1, 
          data = piston_data)
```
:::
::: {.column width="50%"}
```{r}
#| fig-align: center
#| echo: false

gf_violin( cycle_time ~ 1, data = piston_data)
```
:::
:::

## Gráfica de violín vs Gráfica de caja

- La gráfica de caja no revela la forma de la distribución comparada con un histograma o una curva de densidad. 

- Muestran principalmente simetría y sesgo, colas largas/cortas y valores inusualmente grandes/pequeños (también conocidos como *valores atípicos*).

- Las tramas de violín no muestran valores atípicos.

# Actividad

# Applicando el Principio 3

Histograma de precios.

While this plot accurately displays the data, most of the visible bins are crammed into the left side of the plot. This makes it hard to understand the distribution of prices.

::: notes
Through data visualization, we want to reveal important features of the data, like the shape of a distribution and the relationship between two or more features. As this example shows, after we produce an initial plot, there are still other aspects we need to consider. In this section, we cover *principles of scale* that help us decide how to adjust the axis limits, place tick marks, and apply transformations. We begin by examining when and how we might adjust a plot to reduce empty space; in other words, we try to fill the data region of our plot with data.
:::

## Ajustando la escala

Para mejorar la gráfica, puedes ajustar los limites del eje, los tick mars y aplicar transformaciones a la variable.

## Ajustando los límites

Ejemplo de ajustar los límites en ggplot2.

## Ajustando los tick marks

¿Es apropiado incluir el zero o no?

Ejemplo de histograma sin zero y con zero.

## Transformaciones

Another common way to adjust scale is to transform the data or the plot’s axes. We use transformations for skewed data so that it is easier to inspect the distribution.

And when the transformation produces a symmetric distribution, the symmetry carries with it useful properties for modeling (which we will see later).

There are multiple ways to transform data, but the log transformation tends to be especially useful.

## Ejemplo

Ejemplo de histograma con o sin transformación.

## 

The downside of using the log transform is that the actual values aren’t as intuitive—in this example, we needed to convert the values back to dollars to understand the sale price.

Therefore, we often favor transforming the axis to a log scale, rather than the data.

R code con grafica

::: notes
This histogram with its log-scaled x-axis essentially shows the same shape as the histogram of the transformed data. But since the axis is displayed in the original units, we can directly read off the location of the modes in dollars. Note that the bins get narrower to the right because the bin widths are equal on the USD scale but plotted on the log USD scale. Also note that � on the y-axis is 10−6.
:::
